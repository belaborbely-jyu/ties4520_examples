/**
 * This software is copyrighted and licensed; see the accompanying license file for copyright holders and terms.
 */
package info.sswap.impl.empire.model;

import static info.sswap.impl.empire.Namespaces.SSWAP_NS;

import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

import javax.persistence.Entity;

import com.clarkparsia.empire.annotation.Namespaces;
import com.clarkparsia.empire.annotation.RdfProperty;
import com.clarkparsia.empire.annotation.RdfsClass;
import com.clarkparsia.utils.AbstractDataCommand;
import com.clarkparsia.utils.collections.CollectionUtil;

import info.sswap.api.model.SSWAPGraph;
import info.sswap.api.model.SSWAPResource;
import info.sswap.api.model.SSWAPSubject;
import info.sswap.api.model.ValidationException;
import info.sswap.impl.empire.Vocabulary;

/**
 * Partial implementation of SSWAP Graph (the remaining abstract methods are automatically generated by Empire in the
 * run-time).
 * 
 * @author Blazej Bulka <blazej@clarkparsia.com>
 */
@Namespaces( { "sswap", SSWAP_NS })
@Entity
@RdfsClass("sswap:Graph")
public abstract class GraphImpl extends EmpireGeneratedNodeImpl implements SSWAPGraph {

	private ResourceImpl resource;
	
	public GraphImpl() {
		addIgnoredType(Vocabulary.SSWAP_GRAPH.getURI());
	}

	void setResource(SSWAPResource resource) {
		if ((resource == null) || (resource instanceof ResourceImpl)) {
			this.resource = (ResourceImpl) resource;	
		}
		else {
			throw new IllegalArgumentException("The resource has not been created by this API implementation");
		}
	}
	
	/**
	 * @inheritDoc
	 */
	public SSWAPResource getResource() {
		return resource;
	}
	
	/**
	 * @inheritDoc
	 */
	public SSWAPSubject getSubject() {
		SubjectImpl result = null;

		List<SubjectImpl> subjectList = getHasMappingList();

		if ((subjectList != null) && (!subjectList.isEmpty())) {

			result = subjectList.get(0);
		
			if (result != null) {
				// make sure that the source model and the link back to this graph is properly set
				result.addGraph(this);
				result.setSourceModel(getSourceModel());
			}
		}

		return result;
	}

	/**
	 * @inheritDoc
	 */
	public Collection<SSWAPSubject> getSubjects() {
		// convert the list of SubjectImpls (returned by Empire) to the proper type expected by SSWAP (i.e., set of
		// SSWAP subjects)
		// also ensure that the objects have the proper source model set
		Collection<SSWAPSubject> result = listFromImpl(setSourceModel(getHasMappingList(), getSourceModel()), SSWAPSubject.class,
		                SubjectImpl.class);
		
		CollectionUtil.each(result, new AbstractDataCommand<SSWAPSubject>() {
            public void execute() {
            	((SubjectImpl) getData()).addGraph(GraphImpl.this);
            }
		});
		
		return result;
	}

	/**
	 * @inheritDoc
	 */
	public void setSubject(SSWAPSubject subject) {		
		if (subject instanceof SubjectImpl) {
			detachExistingSubjects();
			((SubjectImpl) subject).addGraph(this);
			
			List<SubjectImpl> subjectList = new LinkedList<SubjectImpl>();			
			subjectList.add((SubjectImpl) subject);

			setHasMappingEmpireList(subjectList);
		}
		else {
			throw new IllegalArgumentException(
			                "The SSWAPSubject has been created by a different implementation of the API");
		}
	}

	/**
	 * @inheritDoc
	 */
	public void setSubjects(Collection<SSWAPSubject> subjects) {
		detachExistingSubjects();
		
		CollectionUtil.each(subjects, new AbstractDataCommand<SSWAPSubject>() {
            public void execute() {
            	((SubjectImpl) getData()).addGraph(GraphImpl.this);
            }
		});
		
		setHasMappingEmpireList(toListImpl(subjects, SSWAPSubject.class, SubjectImpl.class));
		persist();
	}

	/**
	 * Gets the list of subjects to which this graph is connected by sswap:hasMapping property.
	 * 
	 * @return the list of subjects or null (if there are no subjects).
	 */
	@RdfProperty("sswap:hasMapping")
	public abstract List<SubjectImpl> getHasMappingEmpireList();
	
	
	public List<SubjectImpl> getHasMappingList() {
		return ensureProperView(getHasMappingEmpireList(), SubjectImpl.class);
	}
	
	/**
	 * Sets the list of subjects to which this graph is connected by sswap:hasMapping property.
	 * 
	 * @param hasMappingList
	 *            the list of subjects or null.
	 */
	public abstract void setHasMappingEmpireList(List<SubjectImpl> hasMappingList);
	
	@Override
	public void validate() throws ValidationException {
		super.validate();
		
		Collection<SSWAPSubject> subjects = getSubjects();
		
		if (subjects.isEmpty()) {
			throw new ValidationException("There are no sswap:Subject defined in this sswap:Graph");
		}
		
		for (SSWAPSubject subject : subjects) {
			subject.validate();
		}
	}
	
	private void detachExistingSubjects() {
		List<SubjectImpl> existingSubjects = getHasMappingList();
		
		if (existingSubjects != null) {
			CollectionUtil.each(existingSubjects, new AbstractDataCommand<SubjectImpl>() {
				public void execute() {
					getData().removeGraph(GraphImpl.this);
				}
			});
		}
	}

}
